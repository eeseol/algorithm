# 요세푸스 문제 (Josephus Problem) - BOJ 11866

## 문제 설명
1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 
이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 
이 과정은 N명의 사람이 모두 제거될 때까지 계속된다.

## 해결 방법들

### 1. 큐(Queue) 사용 - `solution1_queue.py`
- **시간복잡도**: O(N×K)
- **공간복잡도**: O(N)
- **특징**: 
  - 가장 직관적인 방법
  - K-1번 앞에서 빼서 뒤로 보내고, K번째를 제거
  - 구현이 간단하고 이해하기 쉬움

### 2. 연결 리스트(Linked List) 사용 - `solution2_linked_list.py`
- **시간복잡도**: O(N×K)
- **공간복잡도**: O(N)
- **특징**:
  - 원형 연결 리스트로 구현
  - 노드 삭제가 O(1)로 빠름
  - 메모리 할당/해제 오버헤드

### 3. 재귀(Recursive) 사용 - `solution3_recursive.py`
- **시간복잡도**: O(N²)
- **공간복잡도**: O(N) - 재귀 호출 스택
- **특징**:
  - 수학적 공식: J(N,K) = (J(N-1,K) + K - 1) % N + 1
  - 재귀 호출로 인한 스택 오버플로우 위험
  - 큰 N에 대해서는 비효율적

### 4. 반복문(Iterative) 사용 - `solution4_iterative.py`
- **시간복잡도**: O(N²)
- **공간복잡도**: O(N)
- **특징**:
  - 재귀의 반복문 버전
  - 스택 오버플로우 위험 없음
  - 수학적 공식을 반복문으로 구현

### 5. 배열(Array) 사용 - `solution5_array.py`
- **시간복잡도**: O(N×K)
- **공간복잡도**: O(N)
- **특징**:
  - 배열에서 인덱스 계산으로 K번째 사람 찾기
  - pop() 연산으로 인한 O(N) 시간복잡도
  - 구현이 간단함

### 6. 이진 인덱스 트리(Fenwick Tree) 사용 - `solution6_binary_indexed_tree.py`
- **시간복잡도**: O(N×log N)
- **공간복잡도**: O(N)
- **특징**:
  - 가장 효율적인 방법 중 하나
  - k번째 원소 찾기와 업데이트가 O(log N)
  - 구현이 복잡하지만 성능이 좋음

## 성능 비교

| 방법 | 시간복잡도 | 공간복잡도 | 구현 난이도 | 메모리 효율성 |
|------|------------|------------|-------------|---------------|
| 큐 | O(N×K) | O(N) | 쉬움 | 보통 |
| 연결 리스트 | O(N×K) | O(N) | 보통 | 보통 |
| 재귀 | O(N²) | O(N) | 쉬움 | 낮음 |
| 반복문 | O(N²) | O(N) | 쉬움 | 높음 |
| 배열 | O(N×K) | O(N) | 쉬움 | 보통 |
| Fenwick Tree | O(N×log N) | O(N) | 어려움 | 높음 |

## 사용 권장사항

- **N, K가 작은 경우 (N ≤ 1000)**: 큐나 배열 방법
- **N이 큰 경우 (N > 10000)**: Fenwick Tree 방법
- **메모리 제약이 심한 경우**: 반복문 방법
- **구현 속도가 중요한 경우**: 큐 방법

## 예제 실행
```bash
# 입력: 7 3
# 출력: <3, 6, 2, 7, 5, 1, 4>
```

## 참고사항
- 모든 방법은 동일한 결과를 출력합니다
- 실제 백준 문제에서는 큐 방법이 가장 많이 사용됩니다
- Fenwick Tree 방법은 고급 알고리즘 문제에서 유용합니다 